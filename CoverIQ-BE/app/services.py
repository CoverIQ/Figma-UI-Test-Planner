import os
import io
import zipfile
from typing import Dict, Any, List, Optional, Tuple
from dotenv import load_dotenv
from TestPlanner.figma_frame_parser import parse_figma_url, get_figma_file_data
from TestPlanner.feature_representation import filter_component
from TestPlanner.llm_test_plan_generator import generate_test_plan
from TestPlanner.bdd_style_test_case_generator import generate_test_case
from TestPlanner.test_code_generator import generate_E2E_code,generate_feature_text

class DocumentGenerator:
    @staticmethod
    def generate_test_plan_markdown(test_plan: Dict[str, Any]) -> str:
        """Generate markdown content for test plan"""
        markdown = "# Test Plan\n\n"
        
        for index, test_case in enumerate(test_plan['test_plan'], 1):
            markdown += f"## Objective {index}\n\n"
            markdown += f"### Overview\n{test_case['Objective']}\n\n"
            markdown += f"### Scope\n{test_case['Scope']}\n\n"
            markdown += "### Test Items\n\n"
            markdown += f"#### Types of Testing\n{test_case['Test_Items']['Types_of_Testing']}\n\n"
            markdown += f"#### Test Approach\n{test_case['Test_Items']['Test_Approach']}\n\n"
            markdown += "#### Acceptance Criteria\n\n"
            for idx, criteria in enumerate(test_case['Test_Items']['Acceptance_Criteria'], 1):
                markdown += f"{idx}. {criteria}\n"
            markdown += "\n---\n\n"
            markdown += f'> Generated by CoverIQ Test Planner\n\n'
        
        return markdown

    @staticmethod
    def generate_test_cases_markdown(test_cases: Dict[str, Any]) -> str:
        """Generate markdown content for test cases"""
        markdown = "# Test Cases\n\n"
        
        for objective_key, objective in test_cases.items():
            markdown += f"## {objective_key}\n\n"
            markdown += f"### Feature\n{objective['feature']}\n\n"
            
            for idx, description in enumerate(objective['bdd_style_descriptions'], 1):
                markdown += f"### Scenario {idx}\n\n"
                markdown += f"**Scenario:** {description['Scenario']}\n\n"
                markdown += "```gherkin\n"
                markdown += f"Given {description['Given']}\n"
                markdown += f"And {description['And']}\n"
                markdown += f"When {description['When']}\n"
                markdown += f"Then {description['Then']}\n"
                markdown += "```\n\n"
                markdown += "---\n\n"
            markdown += f'> Generated by CoverIQ Test Planner\n\n'
        
        return markdown

    @staticmethod
    def generate_feature_files(test_cases: Dict[str, Any]) :
        """Generate feature files and return as zip bytes"""
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            feature_count = 1
            for objective_key, objective in test_cases.items():
                # Create feature file content
                feature_content = f"Feature: "
                feature_content += f" {feature_count}. {objective['feature']}\n\n"
                
                # Add scenarios
                for idx, description in enumerate(objective['bdd_style_descriptions'], 1):
                    feature_content += f"  Scenario: {idx}. {description['Scenario']}\n"
                    feature_content += f"    Given {description['Given']}\n"
                    feature_content += f"    And {description['And']}\n"
                    feature_content += f"    When {description['When']}\n"
                    feature_content += f"    Then {description['Then']}\n\n"
                feature_content += f"# Generated by CoverIQ Test Planner\n"
                
                # Add to zip file
                feature_filename = f"{objective_key.lower().replace(' ', '_')}.feature"
                zip_file.writestr(feature_filename, feature_content)

        zip_buffer.seek(0)
        return zip_buffer.getvalue()
    
    @staticmethod
    def generate_code_files(test_code: Dict[str, Any]) :
        """Generate code files and return as zip bytes"""
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for filename,content in test_code.items():
                zip_file.writestr(filename, content)
        zip_buffer.seek(0)
        return zip_buffer.getvalue()
    
    

class Feature2Service:
    def __init__(self):
        # In-memory storage
        self._storage = {
            'figma_data': None,
            'feature_list': None,
            'test_plan': None,
            'test_cases': None,
            'test_code' :None,
            'feature_text': None
        }

    def _save_to_memory(self, data: Dict[str, Any], key: str) -> None:
        """Save data to in-memory storage"""
        self._storage[key] = data

    def _read_from_memory(self, key: str) -> Dict[str, Any]:
        """Read data from in-memory storage"""
        if key not in self._storage:
            raise ValueError(f"Invalid data type: {key}")
        if self._storage[key] is None:
            raise FileNotFoundError(f"No data found for: {key}")
        return self._storage[key]

    def parse_figma_url_and_get_data(self, figma_url: str, figma_token: str) -> Dict[str, Any]:
        """Parse Figma URL and get file data"""
        try:
            file_key = parse_figma_url(figma_url)
            figma_data = get_figma_file_data(file_key, figma_token)
            result = {
                "file_key": file_key,
                "figma_data": figma_data
            }
            self._save_to_memory(result, 'figma_data')
            return result
        except Exception as e:
            raise Exception(f"Error parsing Figma URL: {str(e)}")

    def get_feature_representation(self, figma_data: Dict[str, Any], feature_description: Optional[str] = None) -> Dict[str, Any]:
        """Get feature representation from Figma data"""
        try:
            result = filter_component(figma_data, feature_description)
            self._save_to_memory(result, 'feature_list')
            return result
        except Exception as e:
            raise Exception(f"Error getting feature representation: {str(e)}")

    def generate_test_plan_from_feature(self, feature_list: Dict[str, Any], gemini_api_key: str) -> Dict[str, Any]:
        """Generate test plan from feature list"""
        try:
            result = generate_test_plan(feature_list, gemini_api_key)
            self._save_to_memory(result, 'test_plan')
            return result
        except Exception as e:
            raise Exception(f"Error generating test plan: {str(e)}")

    def generate_test_cases_from_plan(self, test_plan: Dict[str, Any], gemini_api_key: str) -> Dict[str, Any]:
        """Generate test cases from test plan"""
        try:
            result = generate_test_case(test_plan, gemini_api_key)
            self._save_to_memory(result, 'test_cases')
            return result
        except Exception as e:
            raise Exception(f"Error generating test cases: {str(e)}")
        
    def generate_feature_from_case(self, test_case: Dict[str, Any]) -> list:
        """Generate test cases from test plan"""
        try:
            result = generate_feature_text(test_case)
            self._save_to_memory(result, 'feature_text')
            return result
        except Exception as e:
            raise Exception(f"Error generating test cases: {str(e)}")
    
    def generate_test_code_from_feature(self, feature_text : List[str], gemini_api_key : str ) -> Dict[str,Any] :
        """Generate test code from test case"""
        try:
            result = generate_E2E_code(feature_text, gemini_api_key)
            self._save_to_memory(result, 'test_code')
            return result
        except Exception as e:
            raise Exception(f"Error generating test cases: {str(e)}")
        

    def get_saved_data(self, data_type: str) -> Dict[str, Any]:
        """Get saved data by type"""
        type_mapping = {
            'figma': 'figma_data',
            'feature': 'feature_list',
            'plan': 'test_plan',
            'cases': 'test_cases',
            '.feature':'feature_text',
            'code' : 'test_code'
        }
        
        if data_type not in type_mapping:
            raise ValueError(f"Invalid data type. Must be one of: {', '.join(type_mapping.keys())}")
            
        return self._read_from_memory(type_mapping[data_type])

def update_env_file(figma_token: str, gemini_key: str) -> Tuple[str, str]:
    """Update environment variables in memory"""
    os.environ["FIGMA_ACCESS_TOKEN"] = figma_token
    os.environ["GEMINI_API_KEY"] = gemini_key
    load_dotenv(override=True)
    return os.getenv("FIGMA_ACCESS_TOKEN"), os.getenv("GEMINI_API_KEY")


# Create a singleton instance
feature2_service = Feature2Service()

# Create a singleton instance
document_generator = DocumentGenerator()
